"""Data models for AI-generated orchestration plans.

This module defines Pydantic models for structured music composition
parameters generated by the AI.
"""

from __future__ import annotations
from typing import Optional, List, Dict, Any
from pydantic import BaseModel, Field, field_validator, model_validator
from enum import Enum


class ScaleType(str, Enum):
    """Available scale types."""
    MAJOR = "major"
    MINOR = "minor"  # Natural minor
    HARMONIC_MINOR = "harmonic_minor"
    MELODIC_MINOR = "melodic_minor"
    DORIAN = "dorian"
    PHRYGIAN = "phrygian"
    LYDIAN = "lydian"
    MIXOLYDIAN = "mixolydian"
    LOCRIAN = "locrian"
    PENTATONIC_MAJOR = "major_pentatonic"
    PENTATONIC_MINOR = "minor_pentatonic"
    BLUES = "blues"
    CHROMATIC = "chromatic"


class FormType(str, Enum):
    """Musical form types."""
    BINARY = "binary"  # AB
    TERNARY = "ternary"  # ABA
    RONDO = "rondo"  # ABACA...
    SONATA = "sonata"  # Exposition-Development-Recapitulation
    THROUGH_COMPOSED = "through_composed"
    STROPHIC = "strophic"  # Same music repeated
    THEME_AND_VARIATIONS = "theme_and_variations"


class DynamicsLevel(str, Enum):
    """Dynamic levels."""
    PP = "pp"  # Pianissimo
    P = "p"  # Piano
    MP = "mp"  # Mezzo-piano
    MF = "mf"  # Mezzo-forte
    F = "f"  # Forte
    FF = "ff"  # Fortissimo
    FFF = "fff"  # Fortississimo


class InstrumentRole(str, Enum):
    """Instrument roles in the ensemble."""
    MELODY = "melody"
    HARMONY = "harmony"
    BASS = "bass"
    ACCOMPANIMENT = "accompaniment"
    COUNTERMELODY = "countermelody"
    OBLIGATO = "obbligato"
    PAD = "pad"
    COLOR = "color"


class InstrumentSection(str, Enum):
    """Orchestral sections."""
    STRINGS = "strings"
    WOODWINDS = "woodwinds"
    BRASS = "brass"
    PERCUSSION = "percussion"
    KEYBOARD = "keyboard"
    PLUCKED = "plucked"
    ELECTRONIC = "electronic"


class InstrumentAssignment(BaseModel):
    """Assignment of an instrument in the composition.

    Attributes:
        name: Instrument name (e.g., "violin", "flute")
        section: Orchestral section
        role: Musical role
        dynamics: Default dynamic level
        when_playing: Which sections this instrument plays in
        midi_program: MIDI program number (0-127)
        range_low: Lowest note (MIDI number)
        range_high: Highest note (MIDI number)
    """

    name: str
    section: InstrumentSection
    role: InstrumentRole = InstrumentRole.HARMONY
    dynamics: DynamicsLevel = DynamicsLevel.MF
    when_playing: List[str] = Field(default_factory=lambda: ["all"])
    midi_program: Optional[int] = None
    range_low: int = 0  # MIDI number
    range_high: int = 127  # MIDI number
    divisi: int = 1  # Number of parts for this instrument

    @field_validator("midi_program")
    @classmethod
    def validate_midi_program(cls, v: Optional[int]) -> Optional[int]:
        if v is not None:
            if not 0 <= v <= 127:
                raise ValueError("MIDI program must be 0-127")
        return v

    @field_validator("range_low", "range_high")
    @classmethod
    def validate_range(cls, v: int) -> int:
        if not 0 <= v <= 127:
            raise ValueError("MIDI range must be 0-127")
        return v


class Section(BaseModel):
    """A musical section of the composition.

    Attributes:
        name: Section identifier (e.g., "A", "B", "development", "coda")
        duration_seconds: Length in seconds
        key: Tonic note (e.g., "C", "F#")
        key_type: Major or minor
        scale_type: Specific scale
        tempo: BPM
        time_signature: e.g., "4/4", "3/4", "6/8"
        mood_description: Brief mood for this section
        instrumentation: Which instruments play
        melody_source: Where melody comes from
        harmonic_center: Tonic, dominant, etc.
        dynamics_start: Starting dynamic
        dynamics_end: Ending dynamic
        texture: Texture density
    """

    name: str
    duration_seconds: int = Field(gt=0, le=600)  # Max 10 minutes per section
    key: str = "C"
    key_type: str = "major"
    scale_type: ScaleType = ScaleType.MAJOR
    tempo: int = Field(default=120, ge=40, le=200)
    time_signature: str = "4/4"
    mood_description: str = ""
    instrumentation: List[str] = Field(default_factory=list)
    melody_source: str = "new"  # "new", "variation", "recap"
    harmonic_center: str = "tonic"  # "tonic", "dominant", "subdominant"
    dynamics_start: DynamicsLevel = DynamicsLevel.MF
    dynamics_end: DynamicsLevel = DynamicsLevel.MF
    texture: str = "homophonic"  # "homophonic", "polyphonic", "melody+accompaniment"


class DynamicsPlan(BaseModel):
    """Plan for dynamic changes throughout the composition.

    Attributes:
        initial_dynamic: Starting dynamic
        climax_dynamic: Peak dynamic
        final_dynamic: Ending dynamic
        climax_point: When climax occurs (0-1, fraction of total duration)
        has_crescendo: Whether to include crescendos
        has_diminuendo: Whether to include diminuendos
        has_sforzando: Accent locations (fractions)
    """

    initial_dynamic: DynamicsLevel = DynamicsLevel.MF
    climax_dynamic: DynamicsLevel = DynamicsLevel.FF
    final_dynamic: DynamicsLevel = DynamicsLevel.MP
    climax_point: float = Field(default=0.75, ge=0.0, le=1.0)
    has_crescendo: bool = True
    has_diminuendo: bool = True
    sforzando_points: List[float] = Field(default_factory=list)  # Locations 0-1


class TextureChange(BaseModel):
    """A change in orchestration texture.

    Attributes:
        time_point: When change occurs (fraction of total duration)
        instruments_adding: Instruments to add
        instruments_removing: Instruments to remove
        new_density: Texture density
        new_role_type: Type of texture
    """

    time_point: float = Field(ge=0.0, le=1.0)
    instruments_adding: List[str] = Field(default_factory=list)
    instruments_removing: List[str] = Field(default_factory=list)
    new_density: str = "medium"  # "thin", "medium", "thick", "tutti"
    new_role_type: str = "homophonic"


class OrchestrationPlan(BaseModel):
    """Complete orchestration plan from AI.

    This is the main output from the AI prompt interpretation,
    containing all parameters needed to generate a complete composition.

    Attributes:
        title: Composition title
        duration_seconds: Total duration (default 180 = 3 minutes)
        key: Tonic note
        scale_type: Musical scale
        tempo: Main tempo in BPM
        time_signature: Main time signature
        sections: List of musical sections
        instruments: List of instrument assignments
        form_type: Musical form
        mood_description: Overall mood
        dynamics_plan: Dynamic arc
        texture_changes: Texture change points
        repeat_sections: Whether to repeat sections
        has_intro: Whether to have an intro
        has_outro: Whether to have an outro/coda
    """

    title: str
    duration_seconds: int = Field(default=180, ge=10, le=600)
    key: str = "C"
    key_type: str = "major"
    scale_type: ScaleType = ScaleType.MAJOR
    tempo: int = Field(default=120, ge=40, le=200)
    time_signature: str = "4/4"

    sections: List[Section] = Field(default_factory=list)
    instruments: List[InstrumentAssignment] = Field(default_factory=list)
    form_type: FormType = FormType.BINARY

    mood_description: str = ""
    dynamics_plan: DynamicsPlan = Field(default_factory=DynamicsPlan)
    texture_changes: List[TextureChange] = Field(default_factory=list)

    repeat_sections: bool = False
    has_intro: bool = False
    has_outro: bool = False

    @model_validator(mode="after")
    def validate_sections(self) -> "OrchestrationPlan":
        if not self.sections:
            # Create default sections
            self.sections = [
                Section(name="A", duration_seconds=90, key="C"),
                Section(name="B", duration_seconds=90, key="G"),
            ]
        return self

    @model_validator(mode="after")
    def validate_instruments(self) -> "OrchestrationPlan":
        if not self.instruments:
            # Create default instruments
            self.instruments = [
                InstrumentAssignment(
                    name="violin",
                    section=InstrumentSection.STRINGS,
                    role=InstrumentRole.MELODY,
                    midi_program=40
                ),
                InstrumentAssignment(
                    name="viola",
                    section=InstrumentSection.STRINGS,
                    role=InstrumentRole.HARMONY,
                    midi_program=41
                ),
                InstrumentAssignment(
                    name="cello",
                    section=InstrumentSection.STRINGS,
                    role=InstrumentRole.HARMONY,
                    midi_program=42
                ),
            ]
        return self

    @property
    def total_duration(self) -> int:
        """Get total duration in seconds."""
        if self.sections:
            return sum(s.duration_seconds for s in self.sections)
        return self.duration_seconds

    @property
    def section_names(self) -> List[str]:
        """Get list of section names."""
        return [s.name for s in self.sections]


class GenerationRequest(BaseModel):
    """Request for music generation.

    Wraps an OrchestrationPlan with additional generation options.

    Attributes:
        plan: The orchestration plan
        export_formats: Formats to export (midi, wav, mp3, musicxml, pdf)
        output_dir: Output directory
        seed: Random seed for reproducibility
    """

    plan: OrchestrationPlan
    export_formats: List[str] = Field(default_factory=lambda: ["midi"])
    output_dir: str = "."
    seed: Optional[int] = None


# Instrument presets for common orchestrations
ORCHESTRAL_INSTRUMENTS = {
    # Strings
    "violin": InstrumentAssignment(
        name="violin", section=InstrumentSection.STRINGS,
        role=InstrumentRole.MELODY, midi_program=40, range_low=55, range_high=96
    ),
    "viola": InstrumentAssignment(
        name="viola", section=InstrumentSection.STRINGS,
        role=InstrumentRole.HARMONY, midi_program=41, range_low=48, range_high=87
    ),
    "cello": InstrumentAssignment(
        name="cello", section=InstrumentSection.STRINGS,
        role=InstrumentRole.HARMONY, midi_program=42, range_low=36, range_high=76
    ),
    "double_bass": InstrumentAssignment(
        name="double_bass", section=InstrumentSection.STRINGS,
        role=InstrumentRole.BASS, midi_program=43, range_low=28, range_high=67
    ),
    # Woodwinds
    "flute": InstrumentAssignment(
        name="flute", section=InstrumentSection.WOODWINDS,
        role=InstrumentRole.MELODY, midi_program=73, range_low=60, range_high=96
    ),
    "clarinet": InstrumentAssignment(
        name="clarinet", section=InstrumentSection.WOODWINDS,
        role=InstrumentRole.MELODY, midi_program=71, range_low=50, range_high=88
    ),
    "oboe": InstrumentAssignment(
        name="oboe", section=InstrumentSection.WOODWINDS,
        role=InstrumentRole.MELODY, midi_program=68, range_low=60, range_high=87
    ),
    "bassoon": InstrumentAssignment(
        name="bassoon", section=InstrumentSection.WOODWINDS,
        role=InstrumentRole.BASS, midi_program=70, range_low=34, range_high=76
    ),
    # Brass
    "trumpet": InstrumentAssignment(
        name="trumpet", section=InstrumentSection.BRASS,
        role=InstrumentRole.MELODY, midi_program=56, range_low=58, range_high=87
    ),
    "french_horn": InstrumentAssignment(
        name="french_horn", section=InstrumentSection.BRASS,
        role=InstrumentRole.HARMONY, midi_program=60, range_low=34, range_high=77
    ),
    "trombone": InstrumentAssignment(
        name="trombone", section=InstrumentSection.BRASS,
        role=InstrumentRole.HARMONY, midi_program=57, range_low=34, range_high=76
    ),
    # Percussion
    "timpani": InstrumentAssignment(
        name="timpani", section=InstrumentSection.PERCUSSION,
        role=InstrumentRole.BASS, midi_program=47, range_low=36, range_high=60
    ),
    # Keyboard
    "piano": InstrumentAssignment(
        name="piano", section=InstrumentSection.KEYBOARD,
        role=InstrumentRole.ACCOMPANIMENT, midi_program=0, range_low=21, range_high=108
    ),
}


def get_orchestral_instrument(name: str) -> InstrumentAssignment:
    """Get an instrument from the orchestral preset library.

    Args:
        name: Instrument name

    Returns:
        InstrumentAssignment preset

    Raises:
        KeyError: If instrument not found
    """
    name_lower = name.lower().replace(" ", "_")
    if name_lower in ORCHESTRAL_INSTRUMENTS:
        return ORCHESTRAL_INSTRUMENTS[name_lower].model_copy()
    raise KeyError(f"Instrument not found: {name}")
