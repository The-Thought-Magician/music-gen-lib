"""AI-generated note and rest models."""

from __future__ import annotations

from enum import Enum
from typing import Union

from pydantic import BaseModel, Field, field_validator


class ArticulationType(str, Enum):
    """Types of articulation markings."""
    STACCATO = "staccato"
    LEGATO = "legato"
    ACCENT = "accent"
    MARCATO = "marcato"
    TENUTO = "tenuto"
    SFORZANDO = "sforzando"


class AINote(BaseModel):
    """A single note generated by AI.

    The AI can specify pitch using:
    - Note name + octave: "C4", "Ab3", "F#5"
    - MIDI number: 60 (C4), 69 (A4)
    - Frequency: 440.0 (A4)
    """

    # Pitch (one of these must be provided)
    note_name: str | None = Field(
        None,
        alias="pitch",
        description="Note name with octave, e.g., 'C4', 'Ab3', 'F#5'",
        pattern=r"^[A-G][#b]?[0-8]$"
    )
    midi_number: int | None = Field(
        None,
        description="MIDI note number (0-127)",
        ge=0,
        le=127
    )
    frequency: float | None = Field(
        None,
        description="Frequency in Hz",
        gt=0
    )

    # Timing
    duration: float = Field(
        ...,
        description="Duration in quarter notes",
        gt=0
    )
    start_time: float = Field(
        default=0.0,
        description="Start time in quarter notes from part start (REQUIRED for polyphony/chords - always specify this value to control when notes play relative to each other)",
        ge=0
    )

    # Velocity/volume
    velocity: int = Field(
        default=80,
        description="MIDI velocity (0-127)",
        ge=0,
        le=127
    )

    # Modifications
    tied: bool = Field(
        default=False,
        description="If True, this note continues to the next"
    )
    articulation: ArticulationType | None = Field(
        None,
        description="Articulation marking"
    )

    @field_validator("note_name")
    @classmethod
    def validate_note_name(cls, v: str | None) -> str | None:
        """Validate note name format."""
        if v is None:
            return None

        if not v:
            return v

        # Convert flats to sharps for consistency
        # Eb -> D#, Bb -> A#, etc.
        flat_to_sharp = {
            "Db": "C#", "Eb": "D#", "Gb": "F#", "Ab": "G#", "Bb": "A#",
            "db": "C#", "eb": "D#", "gb": "F#", "ab": "G#", "bb": "A#",
        }

        # Extract the base note (without octave)
        octave = v[-1] if v[-1].isdigit() else ""
        base = v[:-1] if octave else v

        # Check if it's a flat
        if base in flat_to_sharp:
            base = flat_to_sharp[base]

        return base + octave

    def get_midi_number(self) -> int:
        """Get the MIDI number for this note.

        Converts from note_name or frequency if needed.

        Returns:
            MIDI note number (0-127)
        """
        if self.midi_number is not None:
            return self.midi_number

        if self.note_name is not None:
            # Convert note name to MIDI
            notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"]
            note = self.note_name[:-1]
            octave = int(self.note_name[-1])

            # Handle flats
            if "b" in note:
                base = note.replace("b", "")
                idx = notes.index(base) - 1
            else:
                idx = notes.index(note)

            return 12 * (octave + 1) + idx

        if self.frequency is not None:
            # Convert frequency to MIDI
            # MIDI = 69 + 12 * log2(freq / 440)
            import math
            return int(round(69 + 12 * math.log2(self.frequency / 440.0)))

        raise ValueError("Note must have note_name, midi_number, or frequency")

    def get_frequency(self) -> float:
        """Get the frequency in Hz.

        Returns:
            Frequency in Hz
        """
        if self.frequency is not None:
            return self.frequency

        midi = self.get_midi_number()
        # f = 440 * 2^((midi-69)/12)
        return 440.0 * (2.0 ** ((midi - 69) / 12.0))


class AIRest(BaseModel):
    """A rest generated by AI."""

    duration: float = Field(
        ...,
        description="Duration in quarter notes",
        gt=0
    )
    start_time: float = Field(
        default=0.0,
        description="Start time in quarter notes from part start (REQUIRED for polyphony - always specify this value)",
        ge=0
    )


class ControlChangeEvent(BaseModel):
    """A MIDI Continuous Controller event for expression.

    Used for dynamics, articulation, and other expressive controls.
    """

    controller: int = Field(
        ...,
        ge=0,
        le=127,
        description="MIDI CC number (64=sustain, 11=expression, 7=volume, 10=pan, etc.)"
    )
    value: int = Field(
        ...,
        ge=0,
        le=127,
        description="Controller value (0-127)"
    )
    time: float = Field(
        default=0.0,
        ge=0,
        description="Time in quarter notes from part start"
    )


# Common CC constants
class CC:
    """MIDI Continuous Controller numbers."""

    # Bank and Program
    BANK_SELECT_MSB = 0
    BANK_SELECT_LSB = 32
    MODULATION = 1

    # Channel
    BREATH_CONTROLLER = 2
    FOOT_CONTROLLER = 4
    PORTAMENTO_TIME = 5
    DATA_ENTRY_MSB = 7
    VOLUME = 7
    BALANCE = 8
    PAN = 10
    EXPRESSION = 11

    # Effects
    DAMPER_PEDAL = 64  # Sustain
    PORTAMENTO = 65
    SOSTENUTO = 66
    SOFT_PEDAL = 67
    HOLD_2 = 69

    # Sound Control
    SOUND_VARIATION = 70
    TIMBRE = 71
    RELEASE_TIME = 72
    ATTACK_TIME = 73
    BRIGHTNESS = 74
    DECAY_TIME = 75
    VIBRATO_RATE = 76
    VIBRATO_DEPTH = 77
    VIBRATO_DELAY = 78


# Union type for note events
AINoteEvent = Union[AINote, AIRest]
