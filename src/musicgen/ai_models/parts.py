"""AI-generated part models."""

from __future__ import annotations

from enum import Enum

from pydantic import BaseModel, Field, field_validator

from musicgen.ai_models.notes import AINote, AINoteEvent, AIRest, ControlChangeEvent, CC


class InstrumentRole(str, Enum):
    """Role of an instrument in the composition."""
    MELODY = "melody"
    HARMONY = "harmony"
    BASS = "bass"
    ACCOMPANIMENT = "accompaniment"
    COUNTERMELODY = "countermelody"
    PAD = "pad"
    PERCUSSION = "percussion"


class AIPart(BaseModel):
    """An instrument part generated by AI.

    Contains a sequence of notes for a single instrument.
    """

    # Instrument identification
    name: str = Field(
        ...,
        description="Instrument name (e.g., 'violin', 'piano', 'flute')"
    )
    midi_program: int = Field(
        ...,
        description="MIDI program number (0-127)",
        ge=0,
        le=127
    )
    midi_channel: int = Field(
        default=0,
        description="MIDI channel (0-15, 10 for percussion)",
        ge=0,
        le=15
    )

    # Role
    role: InstrumentRole = Field(
        default=InstrumentRole.MELODY,
        description="Role this part plays in the composition"
    )

    # Notes - can be dict (from JSON) or AINoteEvent (already parsed)
    notes: list[dict | AINote | AIRest] = Field(
        default_factory=list,
        description="List of note/rest objects"
    )

    # Optional dynamics
    dynamics_marking: str | None = Field(
        None,
        description="Dynamic marking (pp, p, mp, mf, f, ff, fff)"
    )
    volume_adjustment: int = Field(
        default=0,
        description="Volume adjustment in decibels (-127 to 127)",
        ge=-127,
        le=127
    )

    # Optional articulation defaults
    default_articulation: str | None = Field(
        None,
        description="Default articulation for notes in this part"
    )

    # Continuous Controller events for expression
    cc_events: list[ControlChangeEvent | dict] = Field(
        default_factory=list,
        description="Continuous controller events for expression"
    )

    # Common shortcuts
    sustain_pedal: bool = Field(
        default=False,
        description="Whether sustain pedal is used (auto-generates CC64 events)"
    )

    @field_validator("notes", mode="before")
    @classmethod
    def validate_notes(cls, v: list) -> list:
        """Validate and convert note dictionaries."""
        validated = []
        for note in v:
            if isinstance(note, dict):
                # Check if it's a rest
                if note.get("rest") is True:
                    validated.append(AIRest(**note))
                else:
                    validated.append(AINote(**note))
            else:
                validated.append(note)
        return validated

    def get_note_events(self) -> list[AINoteEvent]:
        """Get validated note events.

        Returns:
            List of AINote and AIRest objects
        """
        events = []
        for note in self.notes:
            if isinstance(note, dict):
                if note.get("rest") is True:
                    events.append(AIRest(**note))
                else:
                    events.append(AINote(**note))
            elif isinstance(note, (AINote, AIRest)):
                events.append(note)
        return events

    @property
    def duration_quarters(self) -> float:
        """Get total duration in quarter notes.

        Returns:
            Total duration
        """
        return sum(
            n.duration if hasattr(n, "duration") else 0
            for n in self.get_note_events()
        )

    def get_cc_events(self) -> list[ControlChangeEvent]:
        """Get validated CC events.

        Returns:
            List of ControlChangeEvent objects
        """
        events = []
        for cc in self.cc_events:
            if isinstance(cc, dict):
                events.append(ControlChangeEvent(**cc))
            elif isinstance(cc, ControlChangeEvent):
                events.append(cc)

        # Auto-generate sustain pedal if requested
        if self.sustain_pedal:
            # Find if there are already sustain events
            has_sustain = any(
                (isinstance(cc, ControlChangeEvent) and cc.controller == CC.DAMPER_PEDAL) or
                (isinstance(cc, dict) and cc.get("controller") == CC.DAMPER_PEDAL)
                for cc in self.cc_events
            )
            if not has_sustain:
                # Add sustain on at start, off at end
                total_duration = self.duration_quarters
                events.append(ControlChangeEvent(
                    controller=CC.DAMPER_PEDAL,
                    value=127,  # On
                    time=0.0
                ))
                events.append(ControlChangeEvent(
                    controller=CC.DAMPER_PEDAL,
                    value=0,  # Off
                    time=total_duration
                ))

        return sorted(events, key=lambda x: x.time)

    def add_sustain_pedal(
        self,
        on_time: float = 0.0,
        off_time: float | None = None
    ) -> None:
        """Add sustain pedal CC events.

        Args:
            on_time: When to press sustain (quarter notes)
            off_time: When to release (None = end of part)
        """
        self.cc_events.append(ControlChangeEvent(
            controller=CC.DAMPER_PEDAL,
            value=127,  # On
            time=on_time
        ))

        if off_time is None:
            off_time = self.duration_quarters

        self.cc_events.append(ControlChangeEvent(
            controller=CC.DAMPER_PEDAL,
            value=0,  # Off
            time=off_time
        ))
