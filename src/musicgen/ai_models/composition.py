"""AI-generated composition models."""

from __future__ import annotations

from enum import Enum
from typing import Any

from pydantic import BaseModel, Field, field_validator

from musicgen.ai_models.notes import AINote
from musicgen.ai_models.parts import AIPart


class StructureType(str, Enum):
    """Structure type for composition organization."""
    PART_BASED = "part_based"  # Current: each part has its own note list
    MEASURE_BASED = "measure_based"  # NEW: measures contain all parts


class TempoEvent(BaseModel):
    """A tempo change event."""

    time: float = Field(
        ...,
        ge=0,
        description="When this tempo takes effect (quarter notes from start)"
    )
    bpm: int = Field(
        ...,
        ge=20,
        le=300,
        description="New tempo in BPM"
    )


class TimeSignatureEvent(BaseModel):
    """A time signature change event."""

    measure: int = Field(
        ...,
        ge=1,
        description="Measure number where this change takes effect (1-indexed)"
    )
    numerator: int = Field(
        ...,
        ge=1,
        le=32,
        description="Top number of time signature"
    )
    denominator: int = Field(
        ...,
        ge=1,
        le=32,
        description="Bottom number (power of 2: 2, 4, 8, 16)"
    )


class TimeSignature(BaseModel):
    """Time signature."""

    numerator: int = Field(default=4, ge=1, le=32)
    denominator: int = Field(default=4, ge=1, le=32)

    def __str__(self) -> str:
        return f"{self.numerator}/{self.denominator}"


class KeySignature(BaseModel):
    """Key signature."""

    tonic: str = Field(..., description="Tonic note (e.g., 'C', 'F#', 'Bb')")
    mode: str = Field(
        default="major",
        description="Mode (major, minor, dorian, phrygian, etc.)"
    )

    def __str__(self) -> str:
        return f"{self.tonic} {self.mode}"


class AIMeasure(BaseModel):
    """A single measure with all parts' events.

    Used for measure-based composition structure where all parts'
    events for a given measure are grouped together.
    """

    number: int = Field(..., ge=1, description="Measure number (1-indexed)")
    time_signature: TimeSignature | None = Field(
        None,
        description="Optional time signature override for this measure"
    )
    parts: dict[str, list[AINote]] = Field(
        default_factory=dict,
        description="Part name -> list of notes in this measure"
    )

    # Optional measure-level attributes
    dynamic: str | None = Field(
        None,
        description="Dynamic marking for this measure (pp, p, mp, mf, f, ff, fff)"
    )
    tempo: int | None = Field(
        None,
        ge=40,
        le=300,
        description="Tempo change for this measure (BPM)"
    )
    key: KeySignature | None = Field(
        None,
        description="Key change for this measure"
    )


class AIComposition(BaseModel):
    """A complete composition generated by AI.

    This is the main model that validates AI output.
    Supports both part-based and measure-based structures.
    """

    # Structure type
    structure_type: StructureType = Field(
        default=StructureType.PART_BASED,
        description="How the composition is organized"
    )

    # Metadata
    title: str = Field(..., description="Composition title")
    composer: str | None = Field(None, description="Composer name")

    # Timing
    tempo: int = Field(
        default=120,
        description="Initial tempo in BPM",
        ge=40,
        le=300
    )
    time_signature: TimeSignature = Field(
        default_factory=lambda: TimeSignature(),
        description="Initial time signature"
    )

    # Key
    key: KeySignature = Field(
        default_factory=lambda: KeySignature(tonic="C", mode="major"),
        description="Initial key signature"
    )

    # For part-based structure (current/default)
    parts: list[AIPart] = Field(
        default_factory=list,
        description="Instrument parts (for part_based structure)"
    )

    # For measure-based structure (new)
    measures: list[AIMeasure] = Field(
        default_factory=list,
        description="Measures containing all parts (for measure_based structure)"
    )

    # Tempo and meter changes
    tempo_changes: list[TempoEvent] = Field(
        default_factory=list,
        description="Tempo changes throughout the piece"
    )

    time_signature_changes: list[TimeSignatureEvent] = Field(
        default_factory=list,
        description="Time signature changes by measure"
    )

    # Form and structure
    form: str | None = Field(
        None,
        description="Musical form (binary, ternary, rondo, sonata, etc.)"
    )
    mood: str | None = Field(
        None,
        description="Mood description"
    )

    # Optional sections with timing
    sections: list[dict[str, Any]] | None = Field(
        None,
        description="Section definitions with measure ranges"
    )

    # Dynamics
    initial_dynamic: str | None = Field(
        None,
        description="Starting dynamic (pp, p, mp, mf, f, ff, fff)"
    )

    @field_validator("parts")
    @classmethod
    def validate_parts(cls, v: list[AIPart]) -> list[AIPart]:
        """Validate parts."""
        if not v:
            return v  # Allow empty for measure-based structure

        # Check for duplicate MIDI channels
        channels = [p.midi_channel for p in v]
        if len(channels) != len(set(channels)):
            # Note: Channel 10 can be shared for percussion
            non_percussion = [c for c, p in zip(channels, v, strict=False) if p.role != "percussion"]
            if len(non_percussion) != len(set(non_percussion)):
                raise ValueError("Duplicate MIDI channels for non-percussion parts")

        return v

    def get_parts(self) -> list[AIPart]:
        """Get parts, converting from measures if needed.

        Returns:
            List of AIPart objects
        """
        if self.structure_type == StructureType.MEASURE_BASED:
            return self._measures_to_parts()
        return self.parts

    def _measures_to_parts(self) -> list[AIPart]:
        """Convert measure-based to part-based structure.

        Returns:
            List of AIPart objects with notes from all measures combined
        """
        # Collect all notes by part name
        part_notes: dict[str, list[AINote]] = {}
        part_metadata: dict[str, dict] = {}  # Store midi_program, channel, role

        time_offset = 0
        beats_per_measure = 4  # Default, will use time_signature if available

        for measure in self.measures:
            # Get beats per measure for this measure
            if measure.time_signature:
                beats_per_measure = measure.time_signature.numerator
            elif self.time_signature:
                beats_per_measure = self.time_signature.numerator

            for part_name, notes in measure.parts.items():
                if part_name not in part_notes:
                    part_notes[part_name] = []
                    # Try to get metadata from first note if available
                    if notes and hasattr(notes[0], '__dict__'):
                        part_metadata[part_name] = {
                            'midi_program': 0,  # Default
                            'midi_channel': 0,
                            'role': 'melody',
                        }

                # Add measure offset to note start times
                for note in notes:
                    note_with_offset = note.model_copy()
                    if note_with_offset.start_time is not None:
                        note_with_offset.start_time += time_offset
                    else:
                        note_with_offset.start_time = time_offset
                    part_notes[part_name].append(note_with_offset)

            time_offset += beats_per_measure

        # Create AIPart objects
        parts = []
        for idx, (name, notes) in enumerate(part_notes.items()):
            metadata = part_metadata.get(name, {})
            parts.append(AIPart(
                name=name,
                midi_program=metadata.get('midi_program', idx),
                midi_channel=metadata.get('midi_channel', idx % 16),
                role=metadata.get('role', 'melody'),
                notes=notes
            ))

        return parts

    def get_tempo_at(self, time: float) -> int:
        """Get the effective tempo at a given time.

        Args:
            time: Position in quarter notes

        Returns:
            Tempo in BPM
        """
        current_tempo = self.tempo
        for change in sorted(self.tempo_changes, key=lambda x: x.time):
            if change.time <= time:
                current_tempo = change.bpm
        return current_tempo

    def get_time_signature_at(self, measure: int) -> TimeSignature:
        """Get the effective time signature at a given measure.

        Args:
            measure: Measure number (1-indexed)

        Returns:
            TimeSignature object
        """
        current_ts = self.time_signature
        for change in sorted(self.time_signature_changes, key=lambda x: x.measure):
            if change.measure <= measure:
                current_ts = TimeSignature(
                    numerator=change.numerator,
                    denominator=change.denominator
                )
        return current_ts

    @property
    def duration_quarters(self) -> float:
        """Get duration in quarter notes.

        Returns:
            Duration in quarter notes
        """
        if not self.parts:
            return 0.0
        return max(p.duration_quarters for p in self.parts)

    @property
    def duration_seconds(self) -> float:
        """Get duration in seconds.

        Returns:
            Duration in seconds
        """
        # Duration in seconds = (quarters * 60) / tempo
        return (self.duration_quarters * 60) / self.tempo

    @property
    def instrument_names(self) -> list[str]:
        """Get list of instrument names.

        Returns:
            List of instrument names
        """
        return [p.name for p in self.parts]

    def get_part_by_name(self, name: str) -> AIPart | None:
        """Get a part by instrument name.

        Args:
            name: Instrument name

        Returns:
            AIPart if found, None otherwise
        """
        for part in self.parts:
            if part.name.lower() == name.lower():
                return part
        return None

    def get_melody_parts(self) -> list[AIPart]:
        """Get all parts with melody role.

        Returns:
            List of melody parts
        """
        return [p for p in self.parts if p.role == "melody"]

    def get_bass_parts(self) -> list[AIPart]:
        """Get all parts with bass role.

        Returns:
            List of bass parts
        """
        return [p for p in self.parts if p.role == "bass"]
