"""AI-generated composition models."""

from __future__ import annotations

from typing import Any

from pydantic import BaseModel, Field, field_validator

from musicgen.ai_models.parts import AIPart


class TimeSignature(BaseModel):
    """Time signature."""

    numerator: int = Field(default=4, ge=1, le=32)
    denominator: int = Field(default=4, ge=1, le=32)

    def __str__(self) -> str:
        return f"{self.numerator}/{self.denominator}"


class KeySignature(BaseModel):
    """Key signature."""

    tonic: str = Field(..., description="Tonic note (e.g., 'C', 'F#', 'Bb')")
    mode: str = Field(
        default="major",
        description="Mode (major, minor, dorian, phrygian, etc.)"
    )

    def __str__(self) -> str:
        return f"{self.tonic} {self.mode}"


class AIComposition(BaseModel):
    """A complete composition generated by AI.

    This is the main model that validates AI output.
    """

    # Metadata
    title: str = Field(..., description="Composition title")
    composer: str | None = Field(None, description="Composer name")

    # Timing
    tempo: int = Field(
        ...,
        description="Tempo in BPM",
        ge=40,
        le=300
    )
    time_signature: TimeSignature = Field(
        default_factory=lambda: TimeSignature(),
        description="Time signature"
    )

    # Key
    key: KeySignature = Field(
        ...,
        description="Key signature"
    )

    # Parts (instruments and their notes)
    parts: list[AIPart] = Field(
        ...,
        description="Instrument parts",
        min_length=1
    )

    # Form and structure
    form: str | None = Field(
        None,
        description="Musical form (binary, ternary, rondo, sonata, etc.)"
    )
    mood: str | None = Field(
        None,
        description="Mood description"
    )

    # Optional sections with timing
    sections: list[dict[str, Any]] | None = Field(
        None,
        description="Section definitions with measure ranges"
    )

    # Dynamics
    initial_dynamic: str | None = Field(
        None,
        description="Starting dynamic (pp, p, mp, mf, f, ff, fff)"
    )

    @field_validator("parts")
    @classmethod
    def validate_parts(cls, v: list[AIPart]) -> list[AIPart]:
        """Validate parts."""
        if not v:
            raise ValueError("Composition must have at least one part")

        # Check for duplicate MIDI channels
        channels = [p.midi_channel for p in v]
        if len(channels) != len(set(channels)):
            # Note: Channel 10 can be shared for percussion
            non_percussion = [c for c, p in zip(channels, v, strict=False) if p.role != "percussion"]
            if len(non_percussion) != len(set(non_percussion)):
                raise ValueError("Duplicate MIDI channels for non-percussion parts")

        return v

    @property
    def duration_quarters(self) -> float:
        """Get duration in quarter notes.

        Returns:
            Duration in quarter notes
        """
        if not self.parts:
            return 0.0
        return max(p.duration_quarters for p in self.parts)

    @property
    def duration_seconds(self) -> float:
        """Get duration in seconds.

        Returns:
            Duration in seconds
        """
        # Duration in seconds = (quarters * 60) / tempo
        return (self.duration_quarters * 60) / self.tempo

    @property
    def instrument_names(self) -> list[str]:
        """Get list of instrument names.

        Returns:
            List of instrument names
        """
        return [p.name for p in self.parts]

    def get_part_by_name(self, name: str) -> AIPart | None:
        """Get a part by instrument name.

        Args:
            name: Instrument name

        Returns:
            AIPart if found, None otherwise
        """
        for part in self.parts:
            if part.name.lower() == name.lower():
                return part
        return None

    def get_melody_parts(self) -> list[AIPart]:
        """Get all parts with melody role.

        Returns:
            List of melody parts
        """
        return [p for p in self.parts if p.role == "melody"]

    def get_bass_parts(self) -> list[AIPart]:
        """Get all parts with bass role.

        Returns:
            List of bass parts
        """
        return [p for p in self.parts if p.role == "bass"]
